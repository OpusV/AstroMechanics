#include "mantella_bits/armadillo.hpp"

// C++ standard library
#include <cassert>
#include <functional>

// Mantella
#include "mantella_bits/config.hpp"

namespace mant {
  arma::uword Hash::operator()(
      const arma::vec& key) const {
    assert(!key.is_empty() && "Hash.operator(): The key must not be empty.");
    assert(!key.has_nan() && "Hash.operator(): The key must not contain NaNs.");

    arma::uword hashedKey = key.n_elem;

    // The hashing is based on the Boost library (boost::hash_combine), including the magic numbers.
    // @see http://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine

    /** Boost Software License - Version 1.0 - August 17th, 2003
     * 
     * Permission is hereby granted, free of charge, to any person or organization
     * obtaining a copy of the software and accompanying documentation covered by
     * this license (the "Software") to use, reproduce, display, distribute,
     * execute, and transmit the Software, and to prepare derivative works of the
     * Software, and to permit third-parties to whom the Software is furnished to
     * do so, all subject to the following:
     *
     * The copyright notices in the Software and this entire statement, including
     * the above license grant, this restriction and the following disclaimer,
     * must be included in all copies of the Software, in whole or in part, and
     * all derivative works of the Software, unless such copies or derivative
     * works are solely in the form of machine-executable object code generated by
     * a source language processor.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
     * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
     * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     * DEALINGS IN THE SOFTWARE.
     */

    for (const auto& value : key) {
      // This should even work fine if `std::size_t` can not represent more values than `arma::uword`, as the values should just wrap around `arma::uword`.
      hashedKey ^= static_cast<decltype(hashedKey)>(std::hash<double>()(value) + 0b1001'1110'0011'0111'0111'1001'1011'1001 + (hashedKey << 6) + (hashedKey >> 2));
    }

    return hashedKey;
  }

  bool IsEqual::operator()(
      const arma::vec& firstKey,
      const arma::vec& secondKey) const {
    if (arma::size(firstKey) != arma::size(secondKey)) {
      return false;
    } else if (firstKey.has_nan() || secondKey.has_nan()) {
      return false;
    }

    // TODO Explain why this works (based on the C++ specification)
    return arma::approx_equal(firstKey, secondKey, "absdiff", ::mant::machinePrecision);
  }
}
